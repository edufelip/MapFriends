name: iOS Firebase Distribution

on:
  workflow_dispatch: {}
  push:
    branches: [develop]
    paths-ignore:
      - "supabase/**"
      - "docs/**"
      - "web/**"
  pull_request:
    branches:
      - develop
      - release/**
      - hotfix/**
    paths-ignore:
      - "supabase/**"
      - "docs/**"
      - "web/**"

jobs:
  firebase-distribution:
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: macos-latest

    env:
      KEYCHAIN_PASSWORD: ${{ secrets.IOS_ADHOC_KEYCHAIN_PASSWORD }}
      IOS_PROFILE_NAME: ${{ secrets.IOS_ADHOC_PROFILE_NAME }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Write .env
        run: |
          cat <<'ENVEOF' > .env
          ${{ secrets.ENV_FILE_DEV }}
          ENVEOF
          cat <<'ENVEOF' > .env.development
          ${{ secrets.ENV_FILE_DEV }}
          ENVEOF

      - name: Export env vars
        run: |
          while IFS= read -r line; do
            case "$line" in
              ''|\#*) continue ;;
              EXPO_PUBLIC_*=*) echo "$line" >> "$GITHUB_ENV" ;;
            esac
          done < <(sed -e 's/\r$//' .env)

      - name: Set debug API flag
        run: |
          echo "EXPO_PUBLIC_USE_DEV_API=true" >> "$GITHUB_ENV"

      - name: Set Expo environment
        run: |
          echo "EXPO_PUBLIC_ENV=dev" >> "$GITHUB_ENV"
          echo "APP_ENV=dev" >> "$GITHUB_ENV"
          echo "APP_VARIANT=dev" >> "$GITHUB_ENV"
          echo "APP_SUPABASE_ENV=dev" >> "$GITHUB_ENV"

      - name: Validate Expo environment
        run: |
          if [ "$EXPO_PUBLIC_ENV" != "dev" ]; then
            echo "EXPO_PUBLIC_ENV must be 'dev' (got '$EXPO_PUBLIC_ENV')" >&2
            exit 1
          fi
          echo "EXPO_PUBLIC_ENV=$EXPO_PUBLIC_ENV"

      - name: Validate Firebase secrets
        env:
          GOOGLE_SERVICE_INFO_PLIST_BASE64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_BASE64_DEV }}
          FIREBASE_APP_ID_IOS: ${{ secrets.FIREBASE_APP_ID_IOS_DEV }}
          FIREBASE_SERVICE_ACCOUNT_JSON: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
        run: |
          if [ -z "$GOOGLE_SERVICE_INFO_PLIST_BASE64" ]; then
            echo "GOOGLE_SERVICE_INFO_PLIST_BASE64_DEV is not set" >&2
            exit 1
          fi
          if [ -z "$FIREBASE_APP_ID_IOS" ]; then
            echo "FIREBASE_APP_ID_IOS_DEV is not set" >&2
            exit 1
          fi
          if [ -z "$FIREBASE_SERVICE_ACCOUNT_JSON" ]; then
            echo "FIREBASE_SERVICE_ACCOUNT_JSON is not set" >&2
            exit 1
          fi

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: npm
          cache-dependency-path: package-lock.json

      - name: Install JS deps
        run: npm ci

      - name: Ensure iOS native project exists
        run: |
          if [ ! -d ios ] || [ ! -f ios/Podfile ]; then
            npx expo prebuild --platform ios --non-interactive --no-install
          fi
      - name: Patch Podfile for CI
        run: |
          ruby - <<'RUBY'
          podfile_path = "ios/Podfile"
          abort("Missing #{podfile_path}") unless File.exist?(podfile_path)

          content = File.read(podfile_path)
          # Global modular headers break RNFirebase + FirebaseStorage Swift header resolution in CI.
          content.gsub!(/^\s*use_modular_headers!\s*\n/, '')
          firebase_modular_block = <<~'FIREBASE_MODULAR'
            # CI: keep modular headers scoped to Firebase dependencies required by static Swift pods.
            pod 'GoogleUtilities', :modular_headers => true
            pod 'FirebaseCoreInternal', :modular_headers => true
            pod 'FirebaseAppCheckInterop', :modular_headers => true
            pod 'FirebaseAuthInterop', :modular_headers => true
          FIREBASE_MODULAR
          
          use_frameworks_line = /^\s*use_frameworks!\s*:linkage\s*=>\s*:static\s*$/
          if content.match?(use_frameworks_line)
            unless content.include?("$RNFirebaseAsStaticFramework")
              content.sub!(use_frameworks_line) { |line| "$RNFirebaseAsStaticFramework = true\n#{line}" }
            end
          
            unless content.include?("pod 'GoogleUtilities', :modular_headers => true")
              content.sub!(use_frameworks_line) { |line| "#{line}\n\n#{firebase_modular_block.rstrip}" }
            end
          else
            firebase_framework_and_modular_block = <<~'FIREBASE_FRAMEWORKS'
              # RNFirebase: force static frameworks mode so Swift compatibility headers resolve correctly.
              $RNFirebaseAsStaticFramework = true
              use_frameworks! :linkage => :static
          
              #{firebase_modular_block.rstrip}
            FIREBASE_FRAMEWORKS
          
            target_anchor = /^\s*use_expo_modules!\s*$/
            if content.match?(target_anchor)
              content.sub!(target_anchor) { |line| "#{line}\n\n#{firebase_framework_and_modular_block.rstrip}" }
            else
              abort("Unable to locate use_expo_modules! insertion point in #{podfile_path}")
            end
          end
          
          old_rnmbx_v11_block = <<~'OLD_RNMBX'
              if use_v11
                installer.pods_project.build_configurations.each do |config|
                  flags = config.build_settings['OTHER_SWIFT_FLAGS']
                  if flags.nil?
                    config.build_settings['OTHER_SWIFT_FLAGS'] = ['$(inherited)', '-D RNMBX_11']
                  elsif flags.is_a?(Array)
                    unless flags.include?('-D RNMBX_11')
                      flags << '-D RNMBX_11'
                    end
                    config.build_settings['OTHER_SWIFT_FLAGS'] = flags
                  elsif flags.is_a?(String)
                    unless flags.include?('RNMBX_11')
                      config.build_settings['OTHER_SWIFT_FLAGS'] = flags + ' -D RNMBX_11'
                    end
                  end
                end
              end
          OLD_RNMBX

          new_rnmbx_v11_block = <<~'NEW_RNMBX'
              if use_v11
                append_swift_value = lambda do |value, token|
                  if value.nil?
                    ['$(inherited)', token]
                  elsif value.is_a?(Array)
                    value.include?(token) ? value : value + [token]
                  elsif value.is_a?(String)
                    value.include?(token) ? value : value + ' ' + token
                  else
                    value
                  end
                end

                installer.pods_project.build_configurations.each do |config|
                  config.build_settings['OTHER_SWIFT_FLAGS'] =
                    append_swift_value.call(config.build_settings['OTHER_SWIFT_FLAGS'], '-D RNMBX_11')
                end

                installer.pods_project.targets.each do |target|
                  next unless target.name == 'rnmapbox-maps'

                  target.build_configurations.each do |config|
                    config.build_settings['OTHER_SWIFT_FLAGS'] =
                      append_swift_value.call(config.build_settings['OTHER_SWIFT_FLAGS'], '-D RNMBX_11')
                    config.build_settings['SWIFT_ACTIVE_COMPILATION_CONDITIONS'] =
                      append_swift_value.call(config.build_settings['SWIFT_ACTIVE_COMPILATION_CONDITIONS'], 'RNMBX_11')
                  end
                end
              end
          NEW_RNMBX

          if content.include?(old_rnmbx_v11_block)
            content.sub!(old_rnmbx_v11_block, new_rnmbx_v11_block)
          elsif !content.include?("target.name == 'rnmapbox-maps'")
            insertion_anchor = <<~'RNMBX_ANCHOR'
                if defined?($RNMapboxMaps) && $RNMapboxMaps.respond_to?(:post_install)
                  $RNMapboxMaps.post_install(installer)
                end
            RNMBX_ANCHOR

            injected_rnmbx_block = <<~'RNMBX_INJECTED'
                if defined?($RNMapboxMaps) && $RNMapboxMaps.respond_to?(:post_install)
                  $RNMapboxMaps.post_install(installer)
                end
                rnmbx_mapbox_pod = installer.pod_targets.find { |p| p.name == 'MapboxMaps' }
                rnmbx_use_v11 = rnmbx_mapbox_pod && rnmbx_mapbox_pod.version.split('.')[0].to_i >= 11
                if rnmbx_use_v11
                  append_swift_value = lambda do |value, token|
                    if value.nil?
                      ['$(inherited)', token]
                    elsif value.is_a?(Array)
                      value.include?(token) ? value : value + [token]
                    elsif value.is_a?(String)
                      value.include?(token) ? value : value + ' ' + token
                    else
                      value
                    end
                  end

                  installer.pods_project.targets.each do |target|
                    next unless target.name == 'rnmapbox-maps'

                    target.build_configurations.each do |config|
                      config.build_settings['OTHER_SWIFT_FLAGS'] =
                        append_swift_value.call(config.build_settings['OTHER_SWIFT_FLAGS'], '-D RNMBX_11')
                      config.build_settings['SWIFT_ACTIVE_COMPILATION_CONDITIONS'] =
                        append_swift_value.call(config.build_settings['SWIFT_ACTIVE_COMPILATION_CONDITIONS'], 'RNMBX_11')
                    end
                  end
                end
            RNMBX_INJECTED

            if content.include?(insertion_anchor)
              content.sub!(insertion_anchor, injected_rnmbx_block)
            end
          end

          File.write(podfile_path, content)
          RUBY
      - name: Bump iOS build number
        run: |
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $GITHUB_RUN_NUMBER" ios/mapfriends/Info.plist

      - name: Install pods
        env:
          COCOAPODS_CACHE_DIR: ${{ runner.temp }}/.cocoapods-cache
        run: |
          mkdir -p "$COCOAPODS_CACHE_DIR"
          cd ios
          pod install --silent

      - name: Enforce RNMapbox v11 flags in Pods project
        run: |
          set -euo pipefail
          ruby - <<'RUBY'
          require 'xcodeproj'

          project_path = 'ios/Pods/Pods.xcodeproj'
          abort("Missing #{project_path}") unless Dir.exist?(project_path)

          project = Xcodeproj::Project.open(project_path)
          target = project.targets.find { |t| t.name == 'rnmapbox-maps' }
          abort("Target rnmapbox-maps not found in #{project_path}") unless target

          ensure_swift_define = lambda do |value, define_name|
            define_token = "-D #{define_name}"
            if value.nil?
              "$(inherited) #{define_token}"
            elsif value.is_a?(Array)
              values = value.map(&:to_s)
              values << '$(inherited)' unless values.any? { |v| v.include?('$(inherited)') }
              unless values.any? { |v| v.match?(/(^|\s)-D\s+#{Regexp.escape(define_name)}(\s|$)/) }
                values << define_token
              end
              values
            else
              str = value.to_s
              str = "$(inherited) #{str}" unless str.include?('$(inherited)')
              str.match?(/(^|\s)-D\s+#{Regexp.escape(define_name)}(\s|$)/) ? str : "#{str} #{define_token}".strip
            end
          end

          ensure_condition = lambda do |value, condition_name|
            if value.nil?
              "$(inherited) #{condition_name}"
            elsif value.is_a?(Array)
              values = value.map(&:to_s)
              values << '$(inherited)' unless values.any? { |v| v.include?('$(inherited)') }
              values << condition_name unless values.include?(condition_name)
              values
            else
              str = value.to_s
              str = "$(inherited) #{str}" unless str.include?('$(inherited)')
              str.match?(/(^|\s)#{Regexp.escape(condition_name)}(\s|$)/) ? str : "#{str} #{condition_name}".strip
            end
          end

          target.build_configurations.each do |config|
            config.build_settings['OTHER_SWIFT_FLAGS'] =
              ensure_swift_define.call(config.build_settings['OTHER_SWIFT_FLAGS'], 'RNMBX_11')
            config.build_settings['SWIFT_ACTIVE_COMPILATION_CONDITIONS'] =
              ensure_condition.call(config.build_settings['SWIFT_ACTIVE_COMPILATION_CONDITIONS'], 'RNMBX_11')
          end

          project.save
          puts '[ios-ci] Enforced RNMBX_11 for rnmapbox-maps target build settings'
          RUBY

      - name: Verify RNMapbox v11 compile flags
        run: |
          set -euo pipefail

          PODS_PROJECT="ios/Pods/Pods.xcodeproj"
          if [ ! -d "$PODS_PROJECT" ]; then
            echo "Missing $PODS_PROJECT after pod install" >&2
            exit 1
          fi

          SETTINGS_FILE="$RUNNER_TEMP/rnmapbox-build-settings.txt"
          xcodebuild \
            -project "$PODS_PROJECT" \
            -target rnmapbox-maps \
            -configuration Debug \
            -showBuildSettings > "$SETTINGS_FILE"

          OTHER_SWIFT_FLAGS_LINE="$(grep -m1 '^[[:space:]]*OTHER_SWIFT_FLAGS[[:space:]]*=' "$SETTINGS_FILE" || true)"
          SWIFT_CONDITIONS_LINE="$(grep -m1 '^[[:space:]]*SWIFT_ACTIVE_COMPILATION_CONDITIONS[[:space:]]*=' "$SETTINGS_FILE" || true)"

          echo "[ios-ci] $OTHER_SWIFT_FLAGS_LINE"
          echo "[ios-ci] $SWIFT_CONDITIONS_LINE"

          if ! echo "$OTHER_SWIFT_FLAGS_LINE" | grep -q 'RNMBX_11'; then
            echo "rnmapbox-maps missing RNMBX_11 in OTHER_SWIFT_FLAGS" >&2
            exit 1
          fi

          if ! echo "$SWIFT_CONDITIONS_LINE" | grep -q 'RNMBX_11'; then
            echo "rnmapbox-maps missing RNMBX_11 in SWIFT_ACTIVE_COMPILATION_CONDITIONS" >&2
            exit 1
          fi

      - name: Resolve iOS workspace and scheme
        run: |
          set -euo pipefail

          WORKSPACE_PATH="$(find ios -maxdepth 1 -name "*.xcworkspace" | sort | head -n 1)"
          PROJECT_PATH="$(find ios -maxdepth 1 -name "*.xcodeproj" | sort | head -n 1)"

          if [ -z "$WORKSPACE_PATH" ] || [ -z "$PROJECT_PATH" ]; then
            echo "Unable to resolve iOS workspace/project under ios/." >&2
            exit 1
          fi

          PROJECT_BASENAME="$(basename "$PROJECT_PATH" .xcodeproj)"
          WORKSPACE_NAME="$(basename "$WORKSPACE_PATH")"

          SCHEME_NAME="$(PROJECT_BASENAME="$PROJECT_BASENAME" xcodebuild -list -json -workspace "$WORKSPACE_PATH" | ruby -rjson -e 'project = ENV["PROJECT_BASENAME"]; data = JSON.parse(STDIN.read); schemes = data.dig("workspace", "schemes") || []; abort("No schemes found in workspace") if schemes.empty?; preferred = schemes.find { |s| s == project } || schemes.find { |s| s.casecmp?(project) } || schemes.find { |s| s.casecmp?("mapfriends") } || schemes.find { |s| !s.start_with?("Pods-") }; abort("Unable to resolve app scheme") unless preferred; puts preferred')"

          echo "IOS_WORKSPACE_NAME=$WORKSPACE_NAME" >> "$GITHUB_ENV"
          echo "IOS_SCHEME_NAME=$SCHEME_NAME" >> "$GITHUB_ENV"
          echo "[ios-ci] workspace=$WORKSPACE_NAME"
          echo "[ios-ci] scheme=$SCHEME_NAME"

      - name: Align app provisioning profile (Debug)
        env:
          IOS_PROFILE_NAME: ${{ secrets.IOS_ADHOC_PROFILE_NAME }}
        run: |
          set -euo pipefail
          ruby - <<'RUBY'
          require 'xcodeproj'

          profile_name = ENV['IOS_PROFILE_NAME'].to_s.strip
          scheme_name = ENV['IOS_SCHEME_NAME'].to_s.strip
          abort('IOS_ADHOC_PROFILE_NAME is empty') if profile_name.empty?
          abort('IOS_SCHEME_NAME is empty') if scheme_name.empty?

          project_path = Dir['ios/*.xcodeproj'].sort.first
          abort('Unable to find ios/*.xcodeproj') unless project_path

          project = Xcodeproj::Project.open(project_path)
          target = project.targets.find { |t| t.name == scheme_name } ||
                   project.targets.find { |t| t.name.casecmp?(scheme_name) } ||
                   project.targets.find { |t| !t.name.start_with?('Pods-') }
          abort("Unable to resolve app target in #{project_path}") unless target

          debug_cfg = target.build_configurations.find { |cfg| cfg.name == 'Debug' }
          abort("Debug build configuration not found for target #{target.name}") unless debug_cfg

          debug_cfg.build_settings['CODE_SIGN_STYLE'] = 'Manual'
          debug_cfg.build_settings['PROVISIONING_PROFILE_SPECIFIER'] = profile_name

          project.save
          puts "[ios-ci] target=#{target.name} Debug PROVISIONING_PROFILE_SPECIFIER=#{profile_name}"
          RUBY

      - name: Write GoogleService-Info-Dev.plist
        working-directory: ios
        env:
          GOOGLE_SERVICE_INFO_PLIST_BASE64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_BASE64_DEV }}
        run: |
          mkdir -p mapfriends
          echo "$GOOGLE_SERVICE_INFO_PLIST_BASE64" | base64 -d > mapfriends/GoogleService-Info-Dev.plist

      - name: Ensure GoogleService-Info-Dev.plist exists
        run: |
          test -f ios/mapfriends/GoogleService-Info-Dev.plist || (echo "Missing ios/mapfriends/GoogleService-Info-Dev.plist" >&2; exit 1)

      - name: Sync Google Sign-In scheme (dev)
        run: |
          python3 - <<'PY'
          import plistlib
          import sys

          info_path = "ios/mapfriends/Info.plist"
          gservice_path = "ios/mapfriends/GoogleService-Info-Dev.plist"

          with open(gservice_path, "rb") as f:
            gservice = plistlib.load(f)
          scheme = gservice.get("REVERSED_CLIENT_ID")
          if not scheme:
            print("REVERSED_CLIENT_ID missing in GoogleService-Info-Dev.plist", file=sys.stderr)
            sys.exit(1)

          with open(info_path, "rb") as f:
            info = plistlib.load(f)

          url_types = info.get("CFBundleURLTypes", [])
          google_entry = None
          for entry in url_types:
            schemes = entry.get("CFBundleURLSchemes", [])
            if any(s.startswith("com.googleusercontent.apps.") for s in schemes):
              google_entry = entry
              break

          if google_entry is None:
            url_types.append({"CFBundleURLSchemes": [scheme]})
            info["CFBundleURLTypes"] = url_types
          else:
            schemes = [s for s in google_entry.get("CFBundleURLSchemes", []) if not s.startswith("com.googleusercontent.apps.")]
            schemes.insert(0, scheme)
            google_entry["CFBundleURLSchemes"] = schemes

          with open(info_path, "wb") as f:
            plistlib.dump(info, f)
          PY

      - name: Validate Google Sign-In scheme
        run: |
          PLIST_REVERSED=$(/usr/libexec/PlistBuddy -c "Print :REVERSED_CLIENT_ID" ios/mapfriends/GoogleService-Info-Dev.plist)
          if ! /usr/libexec/PlistBuddy -c "Print :CFBundleURLTypes" ios/mapfriends/Info.plist | grep -Fq "$PLIST_REVERSED"; then
            echo "Google Sign-In mismatch: Info.plist missing REVERSED_CLIENT_ID scheme ($PLIST_REVERSED)" >&2
            exit 1
          fi

      - name: Set up keychain and certificates
        env:
          CERT_P12_BASE64: ${{ secrets.IOS_ADHOC_CERT_P12_BASE64 }}
          CERT_PASSWORD: ${{ secrets.IOS_ADHOC_CERT_PASSWORD }}
          PROFILE_BASE64: ${{ secrets.IOS_ADHOC_PROFILE_BASE64 }}
        run: |
          set -euo pipefail
      
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          CERTIFICATE_PATH="$RUNNER_TEMP/build_certificate.p12"
          PROFILE_PATH="$RUNNER_TEMP/build_profile.mobileprovision"
          PROFILE_DEST="$HOME/Library/MobileDevice/Provisioning Profiles/mapfriends-dev.mobileprovision"
      
          CERT_PASSWORD_CLEAN="$(printf '%s' "$CERT_PASSWORD" | tr -d '\r\n')"
          KEYCHAIN_PASSWORD_CLEAN="$(printf '%s' "$KEYCHAIN_PASSWORD" | tr -d '\r\n')"
      
          printf '%s' "$CERT_P12_BASE64" | base64 --decode > "$CERTIFICATE_PATH"
          printf '%s' "$PROFILE_BASE64" | base64 --decode > "$PROFILE_PATH"
      
          if [ ! -s "$CERTIFICATE_PATH" ]; then
            echo "Decoded certificate is empty. Check IOS_ADHOC_CERT_P12_BASE64." >&2
            exit 1
          fi
          if [ ! -s "$PROFILE_PATH" ]; then
            echo "Decoded provisioning profile is empty. Check IOS_ADHOC_PROFILE_BASE64." >&2
            exit 1
          fi
          if [ -z "$KEYCHAIN_PASSWORD_CLEAN" ]; then
            echo "IOS_ADHOC_KEYCHAIN_PASSWORD is empty." >&2
            exit 1
          fi
      
          if ! openssl pkcs12 -in "$CERTIFICATE_PATH" -nokeys -passin pass:"$CERT_PASSWORD_CLEAN" >/dev/null 2>&1; then
            echo "Invalid IOS_ADHOC_CERT_P12_BASE64 or IOS_ADHOC_CERT_PASSWORD mismatch." >&2
            exit 1
          fi
      
          security create-keychain -p "$KEYCHAIN_PASSWORD_CLEAN" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD_CLEAN" "$KEYCHAIN_PATH"
      
          if ! security import "$CERTIFICATE_PATH" \
            -P "$CERT_PASSWORD_CLEAN" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"; then
            echo "Failed to import p12 into keychain. Re-export certificate as .p12 and verify password." >&2
            exit 1
          fi
      
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD_CLEAN" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
      
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp "$PROFILE_PATH" "$PROFILE_DEST"
      - name: Preflight provisioning profile (bundle id and capabilities)
        env:
          EXPECTED_BUNDLE_ID: com.edufelip.mapfriends.dev
          EXPECTED_PROFILE_NAME: ${{ secrets.IOS_ADHOC_PROFILE_NAME }}
        run: |
          set -euo pipefail

          PROFILE_PATH="$HOME/Library/MobileDevice/Provisioning Profiles/mapfriends-dev.mobileprovision"
          if [ ! -f "$PROFILE_PATH" ]; then
            echo "Provisioning profile not found at $PROFILE_PATH" >&2
            exit 1
          fi

          security cms -D -i "$PROFILE_PATH" > "$RUNNER_TEMP/profile.plist"

          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" "$RUNNER_TEMP/profile.plist" 2>/dev/null || true)
          APP_IDENTIFIER=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" "$RUNNER_TEMP/profile.plist" 2>/dev/null || true)
          APS_ENV=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:aps-environment" "$RUNNER_TEMP/profile.plist" 2>/dev/null || true)
          APPLE_SIGN_IN=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:com.apple.developer.applesignin" "$RUNNER_TEMP/profile.plist" 2>/dev/null || true)
          APPLE_SIGN_IN_FIRST=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:com.apple.developer.applesignin:0" "$RUNNER_TEMP/profile.plist" 2>/dev/null || true)

          if [ -z "$PROFILE_NAME" ]; then
            echo "Unable to read provisioning profile name." >&2
            exit 1
          fi

          if [ -n "${EXPECTED_PROFILE_NAME:-}" ] && [ "$PROFILE_NAME" != "$EXPECTED_PROFILE_NAME" ]; then
            echo "Provisioning profile name mismatch. Expected '$EXPECTED_PROFILE_NAME', got '$PROFILE_NAME'." >&2
            exit 1
          fi

          EXPECTED_SUFFIX=".$EXPECTED_BUNDLE_ID"
          if [[ "$APP_IDENTIFIER" != *"$EXPECTED_SUFFIX" ]]; then
            echo "Provisioning profile app identifier '$APP_IDENTIFIER' does not match expected bundle id '$EXPECTED_BUNDLE_ID'." >&2
            exit 1
          fi

          if [ -z "$APS_ENV" ]; then
            echo "Provisioning profile missing Push Notifications entitlement (aps-environment)." >&2
            exit 1
          fi

          if [ -z "$APPLE_SIGN_IN" ]; then
            echo "Provisioning profile missing Sign in with Apple entitlement (com.apple.developer.applesignin)." >&2
            exit 1
          fi

          if [ -z "$APPLE_SIGN_IN_FIRST" ] && ! printf '%s' "$APPLE_SIGN_IN" | grep -qi "Default"; then
            echo "Provisioning profile has Sign in with Apple entitlement, but it does not include 'Default'." >&2
            exit 1
          fi

          echo "Preflight OK: profile='$PROFILE_NAME' app-id='$APP_IDENTIFIER' aps='$APS_ENV' sign-in-with-apple present"

      - name: Build archive (Debug)
        env:
          KEYCHAIN_PATH: ${{ runner.temp }}/app-signing.keychain-db
        run: |
          cd ios
          xcodebuild \
            -workspace "$IOS_WORKSPACE_NAME" \
            -scheme "$IOS_SCHEME_NAME" \
            -configuration Debug \
            -destination "generic/platform=iOS" \
            -archivePath "$PWD/build/mapfriends-dev.xcarchive" \
            archive \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Apple Development" \
            DEVELOPMENT_TEAM=${{ secrets.IOS_TEAM_ID }} \
            PRODUCT_BUNDLE_IDENTIFIER="com.edufelip.mapfriends.dev" \
            BUNDLE_ID_SUFFIX=.dev \
            IOS_PROFILE_NAME="${IOS_PROFILE_NAME}" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH"

      - name: Export IPA (development)
        env:
          KEYCHAIN_PATH: ${{ runner.temp }}/app-signing.keychain-db
        run: |
          cat <<EOF_PLIST > ios/ExportOptionsDevelopment.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>development</string>
            <key>signingStyle</key><string>manual</string>
            <key>compileBitcode</key><false/>
            <key>stripSwiftSymbols</key><true/>
            <key>provisioningProfiles</key>
            <dict>
              <key>com.edufelip.mapfriends.dev</key><string>${IOS_PROFILE_NAME}</string>
            </dict>
          </dict>
          </plist>
          EOF_PLIST

          cd ios
          xcodebuild -exportArchive \
            -archivePath "$PWD/build/mapfriends-dev.xcarchive" \
            -exportOptionsPlist ExportOptionsDevelopment.plist \
            -exportPath "$PWD/build" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH"

      - name: Resolve IPA path
        run: |
          IPA_PATH=$(ls ios/build/*.ipa | head -n 1)
          if [ -z "$IPA_PATH" ]; then
            echo "IPA not found in ios/build" && exit 1
          fi
          echo "IPA_PATH=$IPA_PATH" >> "$GITHUB_ENV"

      - name: Release notes
        run: |
          NOTES=$(git log -1 --pretty=%B)
          echo "RELEASE_NOTES<<EOF" >> "$GITHUB_ENV"
          echo "$NOTES" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Write Firebase service account
        run: |
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}' > firebase-service-account.json

      - name: Upload to Firebase App Distribution
        env:
          GOOGLE_APPLICATION_CREDENTIALS: firebase-service-account.json
        run: |
          npx --yes firebase-tools@latest appdistribution:distribute "$IPA_PATH" \
            --app "${{ secrets.FIREBASE_APP_ID_IOS_DEV }}" \
            --groups "mapfriends" \
            --release-notes "$RELEASE_NOTES"

      - name: Clean Firebase service account
        if: always()
        run: |
          rm -f firebase-service-account.json

      - name: Clean keychain and profiles
        if: always()
        run: |
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          security delete-keychain "$KEYCHAIN_PATH" || true
          rm -f "$HOME/Library/MobileDevice/Provisioning Profiles/"*.mobileprovision || true
